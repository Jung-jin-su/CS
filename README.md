# Java, Spring CS 공부
## Java
1. 상속성
- `하위 클래스가 상위 클래스의 속성들을 상속 받으면서 쉽게 미리 정의된 메서드들을 이용하거나 선언된 변수들을 인스턴스에 지닐 수 있게된다.`
- 프로그래밍에서 보안, 유지보수에 있어 장점이 있기 때문에 자바에서 흔히 사용
- 상속을 위해서는 하위 클래스 선언 후 extends 상위 클래스를 작성해 주면 된다.
    - ex) VipCustomer vip extends Customer(){} => VipCustomer : 하위 클래스, Customer : 상위 클래스
- extends에서 알 수 있듯이 보통 상속된 클래스들은 `상위 클래스일수록 공통된 성질들을 내포하고 하위 클래스일수록 그 상위 클래스의 성질들을 확장(구체화)한다.`

- 생성자의 경우 차이
    - 하위 클래스의 경우 생성자를 호출하면 제일 먼저 상위클래스의 생성자가 먼저 호출된다.
    - 상속되는 내용들이 생성되고 나서 나머지 하위 클래스만의 인스턴스가 생성된다.
    - 이는 사실 컴파일러가 하위 클래스의 생성자 부분에 자동으로 super(); 라고 상위클래스의 생성자 호출을 진행하기 때문이다.
    - `but, 만일 상위 클래스에서의 생성자가 디폴트가 아니라 다른 매개변수를 받아 생성하는 오버로딩이 진행되었다면, 반드시 하위클래스의 생성자 제일 첫 부분에 super(매개변수);를 호출하고나서 다음 인스턴스 설정을 완료해줘야 한다.`
    - `super호출로 인스턴스를 만들어 놓지 않고선 먼저 다른 변수, 메서드(하위 클래스에만 있는것들)을 담는 객체가 없기 때문!`
    - 만약 보안을 위해 상위 클래스의 내용들이 private었다면, 하위 클래스가 상위 클래스의 메서드나 변수들을 사용하기 매우 까다롭다. 이 때 private말고 `protected로 선언해 주면 다른 외부 패키지와 클래스에서는 접근이 제한되지만 상속 관계에 있는 클래스에서는 자유롭게 사용이 가능하다.`

2. 오버라이딩
- 상속관계에 있는 클래스간 이름과 사용방식이 같지만, 클래스에 의해 구별되는 메소드
- 오버로딩 : 가령 생성자를 생성자(), 생성자(매개변수) 등과 같이 동일한 이름이지만 사용방식이 다른 문법

3. 캐스팅
- 하위클래스를 상위클래스로 캐스트 변환해 주는 것이다. 업 캐스팅은 주로 묵시적, 즉 특별한 기법 없이 배정문을 통해 간단하게 구현할 수 있다.
- ex) 상위클래스 이름 = new 하위클래스생성자();

    - 업 캐스팅 예시
        - 만약 Customer에는 이름, 고객번호 정보가 있고 VipCustomer는 Customer를 상속하고 추가로 개인 담당 직원이 배정되어 있다.
        - Customer lee = new VipCustomer();와같이 업 캐스팅을 통해 lee라는 객체를 생성했다면, `원래는 VipCustomer의 정보가 아닌 Customer에 정의된 변수와 메서드에만 접근 가능`
        - 즉, VipCustomer에는 개인 담당자 변수가 있지만, Customer로 업캐스팅 했다면 Customer에는 이와 같은 내용이 포함되어 있지 않기 때문에 사용할 수 없다

        - but, 만약 이미 Customer 클래스에 showinfo()라는 고객이름과 번호를 출력하는 메서드가 정의 되어있었고, VipCustomer에 같은 이름으로 showinfo()라는 고객이름과 번호, 담당 직원과 할인율 등 vip 고객에 대한 정보를 출력하는 메서드가 `오버라이딩 정의되어 있다면 다른 변수와 메서드들과는 다르게 오버라이딩 된 메서드는 상위클래스의 메서드가 아닌 this인 하위클래스의 메서드가 사용된다`
        - 메서드 이름도 하나의 주소에 저장되는데, 오버라이딩 되면서 새로운 주소에 메서드가 저장되고 그것이 호출된다고 추상적으로 이해하면 된다
    - 업 캐스팅 결론
        - 하나의 어레이리스트에 vip, gold, silver 등 여러 클래스의 고객정보를 Customer라는 상위 클래스로 업캐스팅 하여 담는다면 `각 클래스별, 고객 정보를 뽑는 메서드를 이름을 다르게 설정해주어, 여러 if문 분류를 통해 자기에 맞는 메서드를 호출할 필요 없이 각 클래스에 같은 이름을 지닌 메서드들을 정의해 놓았다면, 업캐스팅 되어도 그 메서드에 접근하기 때문에 같은 showinfo() 호출 명령어로 모든 클래스의 동일한 목적의 메서드를 수행` => 이와 같은 성질을 다형성이라고 한다. 또한 이때 컴파일러가 에러를 반환하지 않도록 `@Override` 어노테이션을 위에 선언해주면 안정성 확보

    - 다운 캐스팅
        - 업캐스팅과 상속, 다형성은 불필요한 if문을 통해 분류하는 과정을 비약적으로 단축시켜준다.
        - 그런데 아무리 비슷한 성질을 구체화한 종속 관계라도 다른 기능을 수행하는 상황이 온다.
        - but, 이미 그 객체는 업캐스팅을 한 상태여서 다른 기능을 정의해놓은 메서드에 접근이 불가능
        - 이 때 다운 캐스팅 필요!

        - ex) 동물이라는 상위 클래스에 포유류, 조류, 어류 등과 같은 하위 클래스들이 있다면 업캐스팅을 통해 자다, 먹다, 정보 출력과 같은 공통적인 행위는 오버라이딩을 통한 다형성 메서드를 통해 처리가 가능 but, 포유류가 걷다, 조류가 날다, 어류가 헤엄치다 와 같이 클래스별 각기 다른 메서드를 호출해야할 필요성도 있다.
    
- 정리
    - 상위 클래스 : 동물{종 이름, 나이}
    - 하위 클래스 : 포유류, 조류, 어류
    - 오버라이딩 메서드 : 먹다, 자다, 객체정보출력
    - 다운캐스팅을 통한 행위 구현 : 포유류 - 걷다, 조류 - 날다, 어류 - 헤엄치다

    - 동물 사자 = new 포유류(); //업캐스팅
    - 동물 독수리 = new 조류(); //업캐스팅
    - 동물 참치 = new 어류(); //업캐스팅

    3객체를 ArrayList animal에 담는다.

    for(동물 임시 : animal) { // 오버라이딩, 다형성
        임시.객체정보출력();
        임시.자다();
    } 
    
    for(동물 임시 : animal){ // 다운캐스팅
        if(임시 instance of 포유류){
            포유류 임시2 = (포유류)임시;
            임시2.걷다();
        }
        else if(임시 instance of 조류){
            조류 임시2 = (조류)임시;
            임시2.날다();
        }
        else if(임시 instance of 어류){
            어류 임시2 = (어류)임시;
            임시2.헤엄치다();
        }
    }

